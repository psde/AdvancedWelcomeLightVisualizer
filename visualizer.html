<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Welcome Light Visualizer v0.1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="templates.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background-color: #e0e0e0;
      max-width: 1400px;
      /* Increased max-width */
      margin: 0 auto;
    }

    .main-section {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 15px;
      justify-content: center;
      width: 100%;
    }

    .group-container {
      background-color: #fff;
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 48%;
      /* Almost half width */
      box-sizing: border-box;
    }

    .group-container h3 {
      margin-top: 0;
      font-size: 1.1em;
    }

    label {
      margin-bottom: 4px;
      font-size: 13px;
      display: block;
    }

    .input-row {
      position: relative;
      margin-bottom: 10px;
    }

    .input-row input {
      width: calc(100% - 70px);
      padding: 4px;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 3px;
      box-sizing: border-box;
    }

    .copy-btn,
    .paste-btn {
      position: absolute;
      background-color: #007bff;
      border: none;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      opacity: 1;
      padding: 4px 8px;
    }

    .copy-btn {
      right: 34px;
    }

    .paste-btn {
      right: 0;
    }

    button {
      padding: 6px 12px;
      cursor: pointer;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      margin-bottom: 5px;
      font-size: 13px;
    }

    .dynamic-container {
      width: 100%;
      margin-top: 20px;
    }

    .seq-block {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      background-color: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
    }

    .seq-subblock {
      flex: 1 1 45%;
      background-color: #fff;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .seq-subblock h4 {
      margin-top: 0;
      margin-bottom: 5px;
      font-size: 1em;
    }

    .seq-subblock textarea {
      width: 100%;
      height: 60px;
      font-family: monospace;
      font-size: 11px;
      box-sizing: border-box;
      margin-bottom: 0;
    }

    .chartCanvas {
      margin: 5px 0;
      border: 1px solid #ccc;
      background-color: #fff;
      width: 100%;
      /* Full width */
      flex-basis: 100%;
      /* Force new row in flex wrap */
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .animation-player {
      background-color: #fff;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 100%;
      box-sizing: border-box;
      margin: 15px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: all 0.3s ease;
    }

    .animation-player.sticky {
      position: sticky;
      top: 0;
      z-index: 1000;
      border-bottom: 4px solid #0056b3;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      padding: 5px 15px;
      /* Reduced padding */
    }

    .animation-player.sticky h3 {
      display: none;
      /* Hide title when sticky to save space */
    }

    .animation-player.sticky .controls {
      margin-bottom: 5px;
      /* Compact controls */
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
      width: 100%;
      flex-wrap: wrap;
    }

    .lights-container {
      display: flex;
      flex-direction: row;
      gap: 40px;
      /* Increased gap for separation */
      justify-content: center;
      width: fit-content;
      /* Fit content to make background look nice */
      padding: 15px 20px;
      background-color: #111;
      /* Dark background */
      border-radius: 10px;
      border: 1px solid #444;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .animation-player.sticky .lights-container {
      margin-top: 5px;
      padding: 5px 10px;
      /* Compact lights container when sticky */
    }

    .light-group {
      display: flex;
      flex-direction: row;
      gap: 15px;
      align-items: center;
      width: auto;
    }

    /* Right group needs to be reversed so lights are close to center and label is on far right */
    .light-group.right-group {
      flex-direction: row-reverse;
    }

    .light-group h4 {
      color: #fff;
      /* White text on dark bg */
      min-width: 20px;
      margin: 0;
      font-weight: bold;
      font-size: 1.2em;
    }

    .lights-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: flex-end;
      /* Left lights stick to the right (center) */
    }

    /* Right lights mirrored, so they should stick to the left (center) */
    #rightLights {
      justify-content: flex-end;
      /* row-reverse makes flex-end aligned to the left side */
    }

    /* Left lights: standard row. We want them aligned to the right (closest to center). */
    #leftLights {
      justify-content: flex-end;
    }

    /* Override for specific IDs if needed, but flex-direction row-reverse handles the mirroring. 
       However, we want the grid to be responsive. */

    .light-bulb {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #000;
      border: 2px solid #555;
      position: relative;
      flex-shrink: 0;
    }

    .light-bulb.focused {
      border: 2px solid #ff0000 !important;
      transform: scale(1.1);
      z-index: 10;
    }

    .light-bulb::after {
      content: attr(data-index);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #666;
      /* dark gray when off */
      font-size: 10px;
      pointer-events: none;
      z-index: 2;
    }

    input[type=range] {
      flex-grow: 1;
      min-width: 200px;
      /* Ensure it has some base width */
    }
  </style>
</head>

<body>
  <h2>Advanced Welcome Light Visualizer</h2>

  <div style="margin-bottom: 20px; text-align: center;">
    <label for="templateSelect" style="display: inline-block; margin-right: 10px;">Load Template:</label>
    <select id="templateSelect" onchange="loadSelectedTemplate()">
      <option value="">-- Select a Template --</option>
    </select>
  </div>

  <div class="main-section">
    <!-- Group 1: FLM2 left [0x43] -->
    <div class="group-container">
      <h3>FLM2 Left [0x43]</h3>
      <label for="leftStaging1">Staging1_Data (max 252 Byte):</label>
      <div class="input-row">
        <input type="text" id="leftStaging1" placeholder="252 Byte, z.B. 00, 01, ..." />
        <button class="copy-btn" title="Copy to Clipboard" onclick="copyToClipboard('leftStaging1')">⧉</button>
        <button class="paste-btn" title="Paste from Clipboard" onclick="pasteFromClipboard('leftStaging1')">⤶</button>
      </div>
      <label for="leftStaging2">Staging2_Data (max 252 Byte):</label>
      <div class="input-row">
        <input type="text" id="leftStaging2" placeholder="252 Byte, z.B. 00, 01, ..." />
        <button class="copy-btn" title="Copy to Clipboard" onclick="copyToClipboard('leftStaging2')">⧉</button>
        <button class="paste-btn" title="Paste from Clipboard" onclick="pasteFromClipboard('leftStaging2')">⤶</button>
      </div>
    </div>

    <!-- Group 2: FLM2 right [0x44] -->
    <div class="group-container">
      <h3>FLM2 Right [0x44]</h3>
      <label for="rightStaging1">Staging1_Data (max 252 Byte):</label>
      <div class="input-row">
        <input type="text" id="rightStaging1" placeholder="252 Byte, z.B. 00, 01, ..." />
        <button class="copy-btn" title="Copy to Clipboard" onclick="copyToClipboard('rightStaging1')">⧉</button>
        <button class="paste-btn" title="Paste from Clipboard" onclick="pasteFromClipboard('rightStaging1')">⤶</button>
      </div>
      <label for="rightStaging2">Staging2_Data (max 252 Byte):</label>
      <div class="input-row">
        <input type="text" id="rightStaging2" placeholder="252 Byte, z.B. 00, 01, ..." />
        <button class="copy-btn" title="Copy to Clipboard" onclick="copyToClipboard('rightStaging2')">⧉</button>
        <button class="paste-btn" title="Paste from Clipboard" onclick="pasteFromClipboard('rightStaging2')">⤶</button>
      </div>
    </div>
  </div>

  <div style="text-align: center; margin-bottom: 20px;">
    <button onclick="buildDynamicFields()">Parse & Build Dynamic Fields</button>
    <button onclick="clearAllFields()">Clear All</button>
  </div>

  <div class="animation-player" id="animationPlayer">
    <h3>Real-time Animation</h3>
    <div class="controls">
      <button onclick="togglePlay()">Play/Pause</button>
      <button onclick="stopAnimation()">Stop</button>

      <label for="speedSelect" style="margin-left: 10px;">Speed:</label>
      <select id="speedSelect" onchange="changeSpeed(this.value)">
        <option value="0.5">0.5x</option>
        <option value="1" selected>1.0x</option>
        <option value="1.5">1.5x</option>
      </select>

      <span class="time-display" id="timeDisplay">0 ms</span>
      <input type="range" id="seekSlider" min="0" max="10000" value="0" step="10" oninput="seekAnimation(this.value)">
      <span class="time-display" id="totalTimeDisplay">0 ms</span>
    </div>

    <div class="lights-container">
      <div class="light-group">
        <h4>L</h4>
        <div class="lights-grid" id="leftLights"></div>
      </div>
      <div class="light-group right-group">
        <h4>R</h4>
        <!-- keep flex-direction: row-reverse for right side mirroring -->
        <div class="lights-grid" id="rightLights" style="flex-direction: row-reverse;"></div>
      </div>
    </div>
  </div>

  <div class="dynamic-container" id="dynamicContainer">
    <!-- Dynamic Sequences + Diagrams -->
  </div>

  <script>
    // ============================================================================
    // Global const and helper functions
    // ============================================================================
    const MAX_LEFT1 = 252;
    const MAX_LEFT2 = 168;
    const MAX_RIGHT1 = 252;
    const MAX_RIGHT2 = 168;

    function parseByteString(str) {
      if (!str) return [];
      let arr = str.replace(/\s/g, "").split(",");
      return arr.map(x => x.trim()).filter(x => x !== "");
    }
    function buildByteString(arr) {
      return arr.map(x => x.trim()).join(", ");
    }
    function ensureMaxSize(arr, maxSize) {
      if (arr.length > maxSize) {
        console.warn(`Exceeded Byte-limit: wanted ${maxSize}, have ${arr.length}. Trimming...`);
        arr.length = maxSize;
      }
    }

    // ============================================================================
    // Copy to Clipboard function
    // ============================================================================
    function copyToClipboard(fieldId) {
      const text = document.getElementById(fieldId).value;
      navigator.clipboard.writeText(text)
        .then(() => {
          console.log("Copied to clipboard:", text);
        })
        .catch(err => {
          console.error("Failed to copy!", err);
        });
    }

    // ============================================================================
    // Paste from Clipboard function
    // ============================================================================
    function pasteFromClipboard(fieldId) {
      navigator.clipboard.readText()
        .then(text => {
          document.getElementById(fieldId).value = text;
          console.log("Pasted from clipboard into", fieldId, ":", text);
        })
        .catch(err => {
          console.error("Failed to paste!", err);
        });
    }

    // ============================================================================
    // Clear all Fields function
    // ============================================================================
    function clearAllFields() {
      // Leert alle vier Hauptfelder
      document.getElementById("leftStaging1").value = "";
      document.getElementById("leftStaging2").value = "";
      document.getElementById("rightStaging1").value = "";
      document.getElementById("rightStaging2").value = "";
    }

    // ============================================================================
    // 1) Main storage of Bytes and sequences
    // ============================================================================
    let left1Bytes = [], left2Bytes = [], right1Bytes = [], right2Bytes = [];
    let sequencesLeft = [], sequencesRight = [];

    let chartSketchesLeft = [];
    let chartSketchesRight = [];

    // ============================================================================
    // 2) Main work
    // ============================================================================
    function buildDynamicFields() {
      // 1) Read the main input fields
      const leftStaging1 = document.getElementById("leftStaging1").value;
      const leftStaging2 = document.getElementById("leftStaging2").value;
      const rightStaging1 = document.getElementById("rightStaging1").value;
      const rightStaging2 = document.getElementById("rightStaging2").value;

      // 2) Parse in Byte-Arrays
      left1Bytes = parseByteString(leftStaging1);
      left2Bytes = parseByteString(leftStaging2);
      right1Bytes = parseByteString(rightStaging1);
      right2Bytes = parseByteString(rightStaging2);

      // 3) Check length
      ensureMaxSize(left1Bytes, MAX_LEFT1);
      ensureMaxSize(left2Bytes, MAX_LEFT2);
      ensureMaxSize(right1Bytes, MAX_RIGHT1);
      ensureMaxSize(right2Bytes, MAX_RIGHT2);

      // 4) Extract sequences
      sequencesLeft = parseAllSequencesFromBytes(left1Bytes, left2Bytes);
      sequencesRight = parseAllSequencesFromBytes(right1Bytes, right2Bytes);

      // 5) Create dynamic fields
      renderDynamicSequences();
      rebuildAnimationPlayer();
    }

    // ============================================================================
    // Template Loading Logic
    // ============================================================================
    function initTemplates() {
      const select = document.getElementById('templateSelect');
      if (typeof TEMPLATES === 'undefined') {
        console.warn('TEMPLATES not found. Make sure templates.js is loaded.');
        return;
      }

      for (const key of Object.keys(TEMPLATES)) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = key;
        select.appendChild(option);
      }
    }

    function loadSelectedTemplate() {
      const select = document.getElementById('templateSelect');
      const key = select.value;

      if (!key || !TEMPLATES[key]) return;

      const data = TEMPLATES[key];

      // Update inputs
      document.getElementById('leftStaging1').value = data.left1 || "";
      document.getElementById('leftStaging2').value = data.left2 || "";
      document.getElementById('rightStaging1').value = data.right1 || "";
      document.getElementById('rightStaging2').value = data.right2 || "";

      // Automatically parse and build
      buildDynamicFields();
    }

    // Initialize templates on load
    window.addEventListener('DOMContentLoaded', initTemplates);

    function parseAllSequencesFromBytes(arr1, arr2) {
      const combined = arr1.concat(arr2);
      let idx = 0;
      let seqs = [];

      while (idx + 3 <= combined.length) {
        // Break if "00,00,00"
        if (combined[idx] === "00" &&
          combined[idx + 1] === "00" &&
          combined[idx + 2] === "00") {
          idx += 3;
          break;
        }
        const identifier = combined[idx];
        const lenHigh = combined[idx + 1];
        const lenLow = combined[idx + 2];
        idx += 3;

        const lengthVal = parseInt(lenHigh + lenLow, 16);
        if (isNaN(lengthVal)) break;

        const dataByteCount = lengthVal * 2;
        let endPos = idx + dataByteCount;
        if (endPos > combined.length) {
          console.warn("Sequence data incomplete, break.");
          break;
        }
        const data = combined.slice(idx, endPos);
        idx = endPos;

        seqs.push({ identifier, lengthVal, data });
      }

      // leftover => RAW
      let leftover = combined.slice(idx);
      if (leftover.length > 0) {
        seqs.push({ identifier: "RAW", lengthVal: leftover.length, data: leftover });
      }
      return seqs;
    }

    /**
     * Dynamic fields and diagrams
     */
    function renderDynamicSequences() {
      const container = document.getElementById("dynamicContainer");

      // Cleanup old sketches to prevent memory leaks and ghost interactions
      chartSketchesLeft.forEach(s => { if (s && s.remove) s.remove(); });
      chartSketchesLeft = [];
      chartSketchesRight = [];

      // Sticky Checkbox and Logic
      const playerDiv = document.getElementById("animationPlayer");
      const controlsDiv = playerDiv.querySelector(".controls");

      // Check if sticky checkbox already exists, if not create it
      if (!document.getElementById("stickyToggle")) {
        const stickyLabel = document.createElement("label");
        stickyLabel.style.display = "flex";
        stickyLabel.style.alignItems = "center";
        stickyLabel.style.gap = "5px";
        stickyLabel.style.marginLeft = "auto";
        stickyLabel.style.cursor = "pointer";

        const stickyInput = document.createElement("input");
        stickyInput.type = "checkbox";
        stickyInput.id = "stickyToggle";
        stickyInput.onchange = (e) => {
          if (e.target.checked) {
            playerDiv.classList.add("sticky");
            // Optional: Move up in DOM to ensure it sticks relative to body if needed? 
            // Actually sticky works within flow. We just need to make sure 
            // no parent has overflow: hidden. Body is flex col so it should be fine.

            // One tweak: when sticky, we might want a bit of top margin/padding adjustment
            // so it doesn't overlap weirdly. But CSS box-shadow helps.
          } else {
            playerDiv.classList.remove("sticky");
          }
        };

        stickyLabel.appendChild(stickyInput);
        stickyLabel.appendChild(document.createTextNode("Sticky Player"));
        controlsDiv.appendChild(stickyLabel);
      }

      container.innerHTML = "";

      // Number of blocks
      let maxSeq = Math.max(sequencesLeft.length, sequencesRight.length);

      for (let i = 0; i < maxSeq; i++) {
        const leftSeq = sequencesLeft[i];
        const rightSeq = sequencesRight[i];

        const seqBlock = document.createElement("div");
        seqBlock.className = "seq-block";

        // left Subblock
        const leftSub = document.createElement("div");
        leftSub.className = "seq-subblock";
        let leftH4 = document.createElement("h4");
        leftH4.textContent = `Seq Left #${i + 1}`;
        leftSub.appendChild(leftH4);

        // Textarea
        let leftTA = document.createElement("textarea");
        leftTA.value = leftSeq ? sequenceToString(leftSeq) : "";
        leftTA.oninput = (e) => {
          sequencesLeft[i] = stringToSequence(e.target.value);
          reAssembleLeftBytes();
          updateSingleDiagram("left", i);
          updateVisuals(currentAnimTime); // Live update
        };
        leftSub.appendChild(leftTA);

        seqBlock.appendChild(leftSub);

        // right Subblock
        const rightSub = document.createElement("div");
        rightSub.className = "seq-subblock";
        let rightH4 = document.createElement("h4");
        rightH4.textContent = `Seq Right #${i + 1}`;
        rightSub.appendChild(rightH4);

        // Textarea
        let rightTA = document.createElement("textarea");
        rightTA.value = rightSeq ? sequenceToString(rightSeq) : "";
        rightTA.oninput = (e) => {
          sequencesRight[i] = stringToSequence(e.target.value);
          reAssembleRightBytes();
          updateSingleDiagram("right", i);
          updateVisuals(currentAnimTime); // Live update
        };
        rightSub.appendChild(rightTA);

        seqBlock.appendChild(rightSub);

        let chartDiv = document.createElement("div");
        chartDiv.id = `chartCanvas_${i}`;
        chartDiv.className = "chartCanvas";
        // REMOVED fixed width/height inline styles to let CSS control it
        // But p5 needs a size. We can get it from clientWidth.
        // We'll set a default minimum height.
        chartDiv.style.height = "250px";
        chartDiv.textContent = `Diagram Sequence #${i + 1}`;
        seqBlock.appendChild(chartDiv);

        container.appendChild(seqBlock);

        // Initial p5 Sketch
        let s = createSingleChart(i, chartDiv);
        chartSketchesLeft[i] = s;
        chartSketchesRight[i] = s;
      }
    }

    /**
     * Sequence => Byte-String
     */
    function sequenceToString(seq) {
      if (!seq) return "";
      if (seq.identifier === "RAW") {
        return buildByteString(seq.data);
      }
      let hl = seq.lengthVal.toString(16).padStart(4, "0").toUpperCase();
      let arr = [
        seq.identifier,
        hl.slice(0, 2),
        hl.slice(2, 4),
        ...seq.data
      ];
      return buildByteString(arr);
    }

    /**
     * Text => Sequence { identifier, lengthVal, data } or {RAW}
     */
    function stringToSequence(text) {
      let arr = parseByteString(text);
      if (arr.length < 1) return null;
      if (arr[0] === "RAW" || arr.length < 3) {
        return { identifier: "RAW", lengthVal: arr.length, data: arr };
      }
      let identifier = arr[0];
      let lenHigh = arr[1];
      let lenLow = arr[2];
      let lengthVal = parseInt(lenHigh + lenLow, 16);
      if (isNaN(lengthVal)) lengthVal = 0;
      let data = arr.slice(3);
      return { identifier, lengthVal, data };
    }

    /**
     * Re-assembling => left1Bytes + left2Bytes
     */
    function reAssembleLeftBytes() {
      let combined = [];
      for (let seq of sequencesLeft) {
        if (!seq) continue;
        if (seq.identifier === "RAW") {
          combined.push(...seq.data);
        } else {
          let hl = seq.lengthVal.toString(16).padStart(4, "0").toUpperCase();
          combined.push(seq.identifier, hl.slice(0, 2), hl.slice(2, 4), ...seq.data);
        }
      }
      left1Bytes = combined.slice(0, MAX_LEFT1);
      let leftover = combined.slice(MAX_LEFT1);
      left2Bytes = leftover.slice(0, MAX_LEFT2);
      let leftover2 = leftover.slice(MAX_LEFT2);
      if (leftover2.length > 0) {
        console.warn("Left side data truncated!");
      }
      while (left1Bytes.length < MAX_LEFT1) left1Bytes.push("00");
      while (left2Bytes.length < MAX_LEFT2) left2Bytes.push("00");
      document.getElementById("leftStaging1").value = buildByteString(left1Bytes);
      document.getElementById("leftStaging2").value = buildByteString(left2Bytes);
    }

    /**
     * Re-assembling => right1Bytes + right2Bytes
     */
    function reAssembleRightBytes() {
      let combined = [];
      for (let seq of sequencesRight) {
        if (!seq) continue;
        if (seq.identifier === "RAW") {
          combined.push(...seq.data);
        } else {
          let hl = seq.lengthVal.toString(16).padStart(4, "0").toUpperCase();
          combined.push(seq.identifier, hl.slice(0, 2), hl.slice(2, 4), ...seq.data);
        }
      }
      right1Bytes = combined.slice(0, MAX_RIGHT1);
      let leftover = combined.slice(MAX_RIGHT1);
      right2Bytes = leftover.slice(0, MAX_RIGHT2);
      let leftover2 = leftover.slice(MAX_RIGHT2);
      if (leftover2.length > 0) {
        console.warn("Right side data truncated!");
      }
      while (right1Bytes.length < MAX_RIGHT1) right1Bytes.push("00");
      while (right2Bytes.length < MAX_RIGHT2) right2Bytes.push("00");
      document.getElementById("rightStaging1").value = buildByteString(right1Bytes);
      document.getElementById("rightStaging2").value = buildByteString(right2Bytes);
    }

    /**
     * create ONE p5 instance for every Diagram #i 
     */
    function createSingleChart(seqIndex, containerDiv) {
      return new p5((sketch) => {
        let maxTime = 0;
        let margin = 40;
        let w = 0;
        let h = 0;

        sketch.setup = () => {
          // Use clientWidth to get full width
          let cw = containerDiv.clientWidth;
          let ch = containerDiv.clientHeight || 250;
          let canvas = sketch.createCanvas(cw, ch);
          canvas.parent(containerDiv);

          w = sketch.width - 2 * margin;
          h = sketch.height - 2 * margin;

          // Only start interaction if clicking directly on the canvas
          canvas.mousePressed(() => {
            isDragging = true;
            handleInteraction();
          });
        };

        sketch.windowResized = () => {
          // Optional: handle resize logic if needed. 
          // Re-measure container and resize canvas.
          let cw = containerDiv.clientWidth;
          sketch.resizeCanvas(cw, sketch.height);
          w = sketch.width - 2 * margin;
        };

        sketch.draw = () => {
          sketch.background(255);
          let leftSeq = sequencesLeft[seqIndex];
          let rightSeq = sequencesRight[seqIndex];
          let leftData = parseForChart(leftSeq);
          let rightData = parseForChart(rightSeq);

          // Re-calc maxTime every frame just in case seq changed
          maxTime = Math.max(leftData.maxT, rightData.maxT);
          if (maxTime === 0) maxTime = 1000; // default view

          // Border
          sketch.stroke(0);
          sketch.strokeWeight(1);
          sketch.noFill();
          sketch.rect(margin, margin, w, h);

          // Axis
          sketch.textSize(11);
          sketch.fill(0);
          sketch.noStroke();
          sketch.textAlign(sketch.CENTER);
          sketch.text("Time (ms)", margin + w / 2, margin + h + 30);
          sketch.push();
          sketch.translate(margin - 30, margin + h / 2);
          sketch.rotate(-sketch.HALF_PI);
          sketch.text("Brightness (%)", 0, 0);
          sketch.pop();

          // Define the steps for the X-axis grid
          let gridStep = (maxTime <= 2500) ? 50 : 200;
          let labelStep = maxTime > 2500 ? 1000 : 500;

          // X-axis grid
          sketch.stroke(220);
          sketch.textAlign(sketch.CENTER, sketch.TOP);
          for (let t = 0; t <= maxTime; t += gridStep) {
            let x = sketch.map(t, 0, maxTime, margin, margin + w);
            if (t % labelStep === 0) {
              sketch.noStroke();
              sketch.fill(0);
              sketch.text(`${t}`, x, margin + h + 5);
              sketch.stroke(220);
              sketch.fill(255);
            }
            if (x <= margin + w) {
              sketch.line(x, margin, x, margin + h);
            }
          }
          // Y-axis grid
          sketch.textAlign(sketch.RIGHT, sketch.CENTER);
          for (let bright = 0; bright <= 100; bright += 10) {
            let y = sketch.map(bright, 0, 100, margin + h, margin);
            sketch.noStroke();
            sketch.fill(0);
            sketch.text(`${bright}`, margin - 5, y);
            sketch.stroke(220);
            sketch.fill(255);
            sketch.line(margin, y, margin + w, y);
          }

          // Helper to draw lines
          const drawLine = (pts, color) => {
            if (!pts || pts.length === 0) return;
            sketch.stroke(color);
            sketch.strokeWeight(2);
            sketch.noFill();
            sketch.beginShape();
            for (let p of pts) {
              let x = sketch.map(p.t, 0, maxTime, margin, margin + w);
              let y = sketch.map(p.b, 0, 100, margin + h, margin);
              sketch.vertex(x, y);
            }
            sketch.endShape();
          };

          drawLine(leftData.points, sketch.color(0, 0, 255)); // Blue
          drawLine(rightData.points, sketch.color(255, 0, 0)); // Red

          // Current Position Indicator
          if (typeof currentAnimTime !== 'undefined') {
            let xPos = sketch.map(currentAnimTime, 0, maxTime, margin, margin + w);

            if (xPos >= margin && xPos <= margin + w) {
              sketch.stroke(50);
              sketch.strokeWeight(2);
              sketch.line(xPos, margin, xPos, margin + h);

              sketch.fill(50);
              sketch.noStroke();
              sketch.triangle(xPos, margin + h, xPos - 5, margin + h + 10, xPos + 5, margin + h + 10);
            }
          }
        };

        let isDragging = false;

        // Helper to handle both click and drag
        const handleInteraction = () => {
          // Check if mouse is inside canvas bounds
          if (sketch.mouseX >= 0 && sketch.mouseX <= sketch.width &&
            sketch.mouseY >= 0 && sketch.mouseY <= sketch.height) {

            // Check if within the graph area (with a little tolerance)
            if (sketch.mouseX >= margin && sketch.mouseX <= margin + w) {
              let clickedTime = sketch.map(sketch.mouseX, margin, margin + w, 0, maxTime);
              // Clamp
              if (clickedTime < 0) clickedTime = 0;
              if (clickedTime > maxTime) clickedTime = maxTime;

              // Seek
              seekAnimation(clickedTime);

              // Highlight Lights
              const leftLight = document.getElementById(`left_light_${seqIndex}`);
              const rightLight = document.getElementById(`right_light_${seqIndex}`);
              if (leftLight) leftLight.classList.add('focused');
              if (rightLight) rightLight.classList.add('focused');

              return false;
            }
          }
        };

        const clearInteraction = () => {
          const leftLight = document.getElementById(`left_light_${seqIndex}`);
          const rightLight = document.getElementById(`right_light_${seqIndex}`);
          if (leftLight) leftLight.classList.remove('focused');
          if (rightLight) rightLight.classList.remove('focused');
        };

        // DRAG INTERACTION - Only continue if we started on this canvas
        sketch.mouseDragged = () => {
          if (isDragging) {
            handleInteraction();
          }
        };

        // RELEASE INTERACTION
        sketch.mouseReleased = () => {
          if (isDragging) {
            isDragging = false;
            clearInteraction();
          }
        };

      });
    }

    /**
     * parseForChart(seq): Sum up Duration => Time, Brightness => {maxT, points[]}
     */
    function parseForChart(seq) {
      if (!seq || seq.identifier === "RAW") {
        return { maxT: 0, points: [] };
      }
      let sumT = 0;
      let pts = [];

      // Start with 0ms and 0%
      pts.push({ t: 0, b: 0 });

      // Process the data pairs: First Byte pair creates the first datapoint
      for (let i = 0; i < seq.data.length; i += 2) {
        let durHex = parseInt(seq.data[i], 16) || 0;
        let briHex = parseInt(seq.data[i + 1], 16) || 0;
        sumT += durHex * 10; // Duration in ms (Byte-Value * 10)
        let bri = Math.min(briHex, 100); // Brigthness (0-100%)
        pts.push({ t: sumT, b: bri });
      }

      return { maxT: sumT, points: pts };
    }

    // ============================================================================
    // 3) Update-Button => updateSingleDiagram("left"/"right", i)
    // ============================================================================
    function updateSingleDiagram(side, seqIndex) {

      let s = (side === "left") ? chartSketchesLeft[seqIndex] : chartSketchesRight[seqIndex];
      if (s) s.remove();

      // Create new
      let chartDiv = document.getElementById(`chartCanvas_${seqIndex}`);
      let newSketch = createSingleChart(seqIndex, chartDiv);

      // Save
      chartSketchesLeft[seqIndex] = newSketch;
      chartSketchesRight[seqIndex] = newSketch;
    }

    // ============================================================================
    // Animation Player Logic
    // ============================================================================
    let animationId = null;
    let isPlaying = false;
    let lastFrameTime = 0;
    let currentAnimTime = 0;
    let totalDuration = 0;
    let playbackSpeed = 1.0;

    function rebuildAnimationPlayer() {
      const leftContainer = document.getElementById("leftLights");
      const rightContainer = document.getElementById("rightLights");
      leftContainer.innerHTML = "";
      rightContainer.innerHTML = "";

      // Create lights for Left
      sequencesLeft.forEach((seq, idx) => {
        const div = document.createElement("div");
        div.className = "light-bulb";
        div.dataset.index = idx + 1;
        div.id = `left_light_${idx}`;
        leftContainer.appendChild(div);
      });

      // Create lights for Right
      sequencesRight.forEach((seq, idx) => {
        const div = document.createElement("div");
        div.className = "light-bulb";
        div.dataset.index = idx + 1;
        div.id = `right_light_${idx}`;
        rightContainer.appendChild(div);
      });

      // Calculate total duration (max of all sequences)
      totalDuration = 0;
      [...sequencesLeft, ...sequencesRight].forEach(seq => {
        const dur = getSequenceDuration(seq);
        if (dur > totalDuration) totalDuration = dur;
      });

      const slider = document.getElementById("seekSlider");
      slider.max = totalDuration;
      slider.value = 0;
      document.getElementById("totalTimeDisplay").textContent = `${totalDuration} ms`;

      stopAnimation();
    }

    function getSequenceDuration(seq) {
      if (!seq || seq.identifier === "RAW") return 0;
      let t = 0;
      for (let i = 0; i < seq.data.length; i += 2) {
        let durHex = parseInt(seq.data[i], 16) || 0;
        t += durHex * 10;
      }
      return t;
    }

    function changeSpeed(val) {
      playbackSpeed = parseFloat(val);
    }

    function togglePlay() {
      if (isPlaying) {
        pauseAnimation();
      } else {
        startAnimation();
      }
    }

    function startAnimation() {
      if (isPlaying) return;
      // If at end, restart
      if (currentAnimTime >= totalDuration && totalDuration > 0) {
        currentAnimTime = 0;
      }

      isPlaying = true;
      lastFrameTime = performance.now();
      animationLoop();
    }

    function pauseAnimation() {
      isPlaying = false;
      if (animationId) cancelAnimationFrame(animationId);
    }

    function stopAnimation() {
      pauseAnimation();
      currentAnimTime = 0;
      updateVisuals(0);
      updateControls(0);
    }

    function seekAnimation(val) {
      currentAnimTime = parseFloat(val);
      if (!isPlaying) {
        updateVisuals(currentAnimTime);
        updateControls(currentAnimTime);
      } else {
        // If playing, update time logic needs a reset of lastFrameTime 
        // so we don't jump. But actually we use Delta, so we just
        // set currentAnimTime and ensure lastFrameTime is 'now' to avoid huge delta
        lastFrameTime = performance.now();
      }
    }

    function animationLoop() {
      if (!isPlaying) return;
      const now = performance.now();
      const delta = now - lastFrameTime;
      lastFrameTime = now;

      currentAnimTime += delta * playbackSpeed;

      if (currentAnimTime >= totalDuration) {
        currentAnimTime = totalDuration;
        updateVisuals(currentAnimTime);
        updateControls(currentAnimTime);
        pauseAnimation();
        return;
      }

      updateVisuals(currentAnimTime);
      updateControls(currentAnimTime);

      animationId = requestAnimationFrame(animationLoop);
    }

    function updateControls(time) {
      document.getElementById("seekSlider").value = time;
      document.getElementById("timeDisplay").textContent = `${Math.floor(time)} ms`;
    }

    function updateVisuals(time) {
      // Update Left
      sequencesLeft.forEach((seq, idx) => {
        const el = document.getElementById(`left_light_${idx}`);
        if (el) {
          const bri = getBrightnessAtTime(seq, time);
          applyBrightness(el, bri);
        }
      });

      // Update Right
      sequencesRight.forEach((seq, idx) => {
        const el = document.getElementById(`right_light_${idx}`);
        if (el) {
          const bri = getBrightnessAtTime(seq, time);
          applyBrightness(el, bri);
        }
      });
    }

    function applyBrightness(element, brightness) {
      // Brightness 0-100
      // Visual: scale color from black to white/blueish (LED)
      // Let's use a nice LED Cyan/White color: #E0F7FA (224, 247, 250)
      // Base is #000

      // Simple grayscale for now as requested "white" usually, but BMW welcome lights are often distinctive.
      // Let's stick to simple white/gray scale.
      const val = Math.round((brightness / 100) * 255);

      // For visibility on dark bg:
      // Background color
      element.style.backgroundColor = `rgb(${val}, ${val}, ${val})`;

      // Glow effect
      if (brightness > 0) {
        element.style.boxShadow = `0 0 ${brightness / 3}px rgba(255, 255, 255, ${brightness / 100})`;
        element.style.borderColor = `rgb(${val}, ${val}, ${val})`;
      } else {
        element.style.boxShadow = `none`;
        element.style.borderColor = `#555`;
      }
    }

    function getBrightnessAtTime(seq, timeObj) {
      if (!seq || seq.identifier === "RAW") return 0;

      // Interpolation Logic matching the Chart
      let tStart = 0;
      let bStart = 0;

      for (let i = 0; i < seq.data.length; i += 2) {
        let durHex = parseInt(seq.data[i], 16) || 0;
        let briHex = parseInt(seq.data[i + 1], 16) || 0;
        let stepDur = durHex * 10;
        let bEnd = Math.min(briHex, 100);
        let tEnd = tStart + stepDur;

        if (timeObj >= tStart && timeObj <= tEnd) {
          // Interpolate
          if (stepDur === 0) return bEnd;
          let progress = (timeObj - tStart) / stepDur;
          return bStart + (bEnd - bStart) * progress;
        }

        tStart = tEnd;
        bStart = bEnd;
      }
      return bStart; // Hold last value
    }

    window.onload = buildDynamicFields;
  </script>
</body>

</html>